<?php
/**
 * @file
 * Drupal core hook implementations and global functionality. 
 */

require_once __DIR__ .'/iwformatter.fields.inc';

define('IWFORMATTER_VAR_DOCK_ENTITY_ACTIONS', 'iwformatter_dock_entity_form_actions');


/**
 * Implements HOOK_html_head_alter().
 */
function iwformatter_html_head_alter(&$header) {
  $header["font-awesome:bootstrap"] = array(
    '#type' => 'html_tag',
    '#tag' => 'link',
    '#attributes' => array(
      'href' => '//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css',
      'rel' => 'stylesheet',
    ),
  );
}

/**
 * Implements HOOK_menu().
 */
function iwformatter_menu() {
  $menu['admin/config/system/iwapi-utils/iwformatter'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Formatting',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('iwformatter_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'pages/admin.inc',
    'description' => 'Manage settings for '
  );

  $menu['field-page/%/%iwapi_entity_object/%iwformatter_field_field'] = array(
    'type'  => MENU_NORMAL_ITEM,
    'load arguments' => array(1), // pass the entity type
    'title' => 'Display field',
    'page callback'   => '_iwformatter_field_page',
    'page arguments'  => array(1, 2, 3),
    'access callback' => 'field_access',
    'access arguments' => array('view', 3, 1, 2),
    'file' => 'iwformatter.pages.inc',
  );

  foreach (entity_get_info() as $type_name => $entity_info) {
    if (empty($entity_info['fieldable'])) {
      continue;
    }

    foreach ($entity_info['bundles'] as $name => $bundle) {
      if (!empty($bundle['admin']['path'])) {
        $wrapper_path = $bundle['admin']['path'] .'/wrappers/%iwformatter_wrapper_menu/delete';

        // Not already defined, since bundles within a entity type will follow the
        // same pattern we should check if this has already happened.
        if (empty($menu[$wrapper_path])) {
          $arg_pos = count(explode('/', $wrapper_path)) - 2;

          // This is the default access.
          $access = array(
            'access callback' => 'user_access',
            'access arguments' => array('administer site configuration'),
          );
          $access = array_intersect_key($bundle, $access) + $access;

          // Ensure the correct bundle information gets passed.
          $bundle_arg = empty($bundle['admin']['bundle argument'])
            ? $name : $bundle['admin']['bundle argument'];

          $menu[$wrapper_path] = array(
            'type' => MENU_CALLBACK,
            'load arguments' => array($type_name, $bundle_arg, '%map'),
            'title' => 'Confirm content wrapper delete',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('iwformatter_content_wrapper_delete_confirm', $arg_pos),
            'file' => 'pages/formatter_ui.admin.inc',
          ) + $access;

          $menu[$bundle['admin']['path'] .'/display/view-modes'] = array(
            'type' => MENU_LOCAL_TASK,
            'title' => 'View Modes',
            'weight' => 100,
            'page callback' => 'drupal_get_form',
            'page arguments' => array('iwformatter_entity_view_mode_form', $type_name, $bundle_arg),
            'file' => 'pages/formatter_ui.admin.inc',
          ) + $access;
        }
      }
    }
  }

  return $menu;
}

/**
 * Implements HOOK_menu_alter()
 */
function iwformatter_menu_alter(&$items) {
  if (!variable_get('iwformatter_override_field_ui', FALSE)) {
    return;
  }
    
  $handled = array();
  foreach (entity_get_info() as $type_name => $entity_info) {
    if (empty($entity_info['fieldable'])) {
      continue;
    }

    foreach ($entity_info['bundles'] as $name => $bundle) {
      if (empty($bundle['admin']['path']) || isset($handled[$bundle['admin']['path']])) {
        continue;
      }
      
      $bundle_path = $bundle['admin']['path'];
      $handled[$bundle_path] = TRUE;
        
      $keys = array_keys($entity_info['view modes']);
      array_walk($keys, '_iwapi_prefix_value', $bundle_path .'/display/');
      $alter = array_fill_keys($keys, 'display');
      $alter[$bundle_path .'/fields']  = 'field';
      $alter[$bundle_path .'/display'] = 'display';
        
      foreach ($alter as $path => $style) {
        if (isset($items[$path]) && !empty($items[$path]['page arguments'])) {
          array_shift($items[$path]['page arguments']);
          array_unshift($items[$path]['page arguments'], "iwformatter_entity_{$style}_form");
          $items[$path]['module'] = 'iwformatter';
          $items[$path]['file'] = "pages/{$style}_ui.inc";
        }
      }
    }
  }
}

/**
 * Implements HOOK_entity_attacher_info().
 */
function iwformatter_entity_attacher_info() {
  return array(
    'field_wrapper' => array(
      'label'   => t('Content wrappers'),
      'handler' => 'iwFieldWrapperAttacher',
    ),
  );
}

/**
 * Implements HOOK_iwformatter_wrapper_types().
 */
function iwformatter_iwformatter_wrapper_types() {
  // Describe iwContentWrapper classes specific to field_groupings.
  return array(
    'iwInlineFieldWrapper' => t('Inline fields'),
    'iwConditionalFieldWrapper' => t('Conditional display'),
  );
}

/**
 * Implements HOOK_field_attach_form().
 */
function iwformatter_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  list($id, $rev, $bundle) = entity_extract_ids($entity_type, $entity);
  $grid = variable_get("iwformatter_{$entity_type}_{$bundle}_grid", 12);
  
  $form['#attributes']['class'][] = 'grid-size-'. $grid;
  _iwformatter_attach_field_wrappers($form, $entity_type, $entity, 'form');
  
  if (variable_get(IWFORMATTER_VAR_DOCK_ENTITY_ACTIONS, TRUE) && isset($form['actions']['#type']) && $form['actions']['#type'] === 'actions') {
    drupal_add_library('iwapi', 'iwapi.docking');
    
    // Make the form actions dock to the bottom of the page.
    $defaults = array('iwapi-dockable', 'dock-bottom-attach');
    $form['actions']['#attributes']['class'] = empty($form['actions']['#attributes']['class'])
      ? $defaults : array_merge($form['actions']['#attributes']['class'], $defaults); 
  }
}

/**
 * Implements HOOK_field_attach_view_alter().
 */
function iwformatter_field_attach_view_alter(&$element, $context) {
  $type      = $context['entity_type'];
  $entity    = $context['entity'];
  $view_mode = $context['view_mode'];

  _iwformatter_attach_field_wrappers($element, $type, $entity, $view_mode);
}

/**
 * If formatter is set, get the class name of
 * the handler for the field formatter type. If a
 * string is provided, 
 * 
 * @param string $formatter
 *  Name of the field formatter type being requested
 *  if only a single response is required. If NULL
 *  return all the available handlers.
 */
function iwformatter_get_format_handlers($formatter = NULL) {
  static $handlers;
  
  if (!isset($handlers)) {
    $handlers = array(
      'iwformatter_field_page'   => 'iwFieldPageFormatter',
      'iwformatter_image_styles' => 'iwMultiImageFormatter',
    );
    
    // Allow manipulation of the formatter associations.
    drupal_alter('iwformatter_format_handlers', $handlers);
  }
  
  if (isset($formatter)) {
    return empty($handlers[$formatter]) ? FALSE : $handlers[$formatter];
  }
  return $handlers;
}

/**
 * Implements HOOK_theme().
 */
function iwformatter_theme($existing, $type, $theme, $path) {
  $base = array(
    'path' => $path .'/theme',
    'file' => 'theme.inc',
  );
  
  return array(
    'iwformatter_field_page' => array(
      'render element' => 'field_data',
      'template' => 'field-page',
      'pattern' => 'field_page__',
    ) + $base,
    'iwformatter_fieldgroup' => array(
      'render element' => 'element',
      'template' => 'iwformatter-fielgroup',
      'pattern' => 'iwformatter_fieldgroup__',
    ) + $base,
  );
}


// ================================
// Menu load callbacks
// ================================

/**
 * Menu load callback to return a content wrapper
 * based on bundle admin / management pages.
 * 
 * @param string $name
 *  Name of the content wrapper in the field grouping scope.
 * @param string $type
 *  Entity type name to use in determing the field group scope.
 * @param type $bundle
 *  Either the bundle string name or the bundle object.
 * @param array $map
 *  The array of page arguments passed to this load callback.
 */
function iwformatter_wrapper_menu_load($name, $type, $bundle, $map) {
  $bundle_name = is_string($bundle) ? strtr($bundle, '-', '_') : field_extract_bundle($type, $bundle);
  
  $view_mode = array_pop($map);
  if ($view_mode == 'delete') {
    $view_mode = 'form';
  }
  
  $wrap_name = preg_replace('/^wrapper_/', '', $name);
  return iwFieldGroupController::LoadContainer($wrap_name, $type, $bundle_name, $view_mode);
}

/**
 * Retrieves the field information related to the field
 * specified by the entity type and field name. 
 *
 * @param string $field_name
 *  Name of the field.
 * @param string $entity_type
 *  String representing the entity
 * @return boolean | array
 *  Boolean FALSE on failure, and an array definition of
 *  the field info if found.
 *  
 * @see field_field_info() for information about the
 *  field definition array structure and meaning.
 */
function iwformatter_field_field_load($field_name, $entity_type) {
  $field_name = str_replace('-', '_', $field_name);

  if ($field = field_info_field($field_name)) {
    return empty($field['bundles'][$entity_type]) ? FALSE : $field;
  }
  return FALSE;
}


// =================================
// Theming HOOKs
// =================================

/**
 * Implments HOOK_preprocess_node().
 */
function iwformatter_preprocess_node(&$vars) {
  $grid = variable_get("iwformatter_node_{$vars['type']}_grid", 12);
  $vars['content_attributes_array']['class'][] = 'grid-size-'. $grid;
}

/**
 * Implements HOOK_preprocess_iwentity().
 */
function iwformatter_preprocess_iwentity(&$vars) {
  $grid = variable_get("iwformatter_{$vars['entity_type']}_{$vars['bundle']}_grid", 12);
  $vars['content_attributes_array']['class'][] = 'grid-size-'. $grid;
}


// =================================
// Utility functions
// =================================

/**
 * Get a list of the formatter types that can be rendered
 * as in a single line with a simple text separator.
 *
 * @return array
 *  With the formatter names which can support being
 *  combined into a single list.
 */
function _iwformatter_listable_formatters() {
  return array(
    'text_plain' => 'text_plain',
    'text_default' => 'text_default',
    'list_default' => 'list_default',
    'taxonomy_term_reference_link' => 'taxonomy_term_reference_link',
    'taxonomy_term_reference_plain' => 'taxonomy_term_reference_plain',
  );
}

/**
 * Utility to help determine if an item can be
 * displayed as a list of values with a separator.
 * 
 * @param array $field
 *  The field definition as loaded from field_info_field().
 * @param array $display
 *  The current display formatter settings.
 * @return boolean
 *  If the field qualifies as a listable format item.
 */
function _iwformatter_is_listable_formatter($field, $display) {
  $listable = _iwformatter_listable_formatters();

  // 0 means unlimited, and cardinality > 1 both mean render list
  // of items, 1 is the only value that should be excluded.
  if ($field['cardinality'] != 1) {
    switch ($display['type']) {
      case 'text_default':
      case 'text_plain':
        return $field['type'] == 'text';
   
      default:
        return isset($listable[$display['type']]);
    }
  }
}


// -------------------------------------
// Field wrapper utils / callbacks
// -------------------------------------

/**
 * Apply field groupings to an element. Field groupings are
 * specific to a combination of entity type, bundle and view mode.
 *
 * @param array $element
 *  Reference to the element being modified with the field groupings.
 * @param string $type
 *  Entity type machine name.
 * @param object $entity
 *  Loaded entity object of $type, for which to apply groupings for.
 * @param string $view_mode
 *  The view mode being used to view the $entity object.
 */
function _iwformatter_attach_field_wrappers(array &$element, $type, $entity, $view_mode) {
  list($id, $rev, $bundle) = entity_extract_ids($type, $entity);

  // Determine the correct view_mode to use
  if ($view_mode !== 'form') {
    $settings  = field_view_mode_settings($type, $bundle);
    $view_mode = !empty($settings[$view_mode]['custom_settings']) ? $view_mode : 'default';
  }

  $wrappers = iwFieldGroupController::LoadContainers($type, $bundle, $view_mode);
  $names    = array_keys($wrappers);
  
  foreach ($wrappers as $key => $wrapper) {
    $element[$key] = $wrapper->view();
 
    $element['#iwformat_wrappers'][$key] = (object)array(
      'key'     => $key,
      'wrapper' => $wrapper,
      'visited' => FALSE,
      'depends' => array_intersect($names, $wrapper->children),
    );
  }

  if (!empty($element['#iwformat_wrappers'])) {
    $element['#pre_render'][] = '_iwformatter_field_wrapper_pre_render';
  }
}

/**
 * Element pre_render callback, to make structural changes
 * before the actual rendering occurs. This will apply
 * the field groupings to the element.
 *
 * @param array $element
 *  The element with loaded field group items to apply.
 * @return array
 *  Altered $element array, which contains an updated element
 *  which is ready to be rendered.
 */
function _iwformatter_field_wrapper_pre_render(array $element) {
  $stack = array();
  
  $wrappers = $element['#iwformat_wrappers'];
  while ($wrapper = array_shift($wrappers)) {
    $stack[$wrapper->key] = $wrapper;
    
    while ($tos = end($stack)) {
      if (empty($tos->depends)) {
        $tos->wrapper->transferItems($element, $element[$tos->key]);
        $tos->visited = TRUE;
      }
      else {
        // Append any dependencies to the stack for resolution.
        foreach ($tos->depends as $key) {
          if (key_exists($key, $wrappers)) {
            $stack[$key] = $wrappers[$key];
            unset($wrappers[$key]); // handled, take out of remaining.
          }
        }
        unset($tos->depends);
        continue; // loop but don't take anything off the top.
      }
      
      array_pop($stack);
    }
  }

  return $element;
}
