<?php
/**
 * @file
 * Drupal core HOOKs and global functionality.
 */

define('DISCOURSE_COMMENTS_VAR_ENTITIES', 'discourse_comments_entities');
define('DISCOURSE_COMMENTS_VAR_CANONICAL', 'discourse_comments_canonical');

define('DISCOURSE_COMMENTS_VAR_SERVER', 'discourse_comments_server');
define('DISCOURSE_COMMENTS_VAR_POST_MISSING', 'discourse_comments_post_missing');
define('DISCOURSE_COMMENTS_VAR_FETCH_PARAMS', 'discourse_comments_fetch_params');
define('DISCOURSE_COMMENTS_VAR_RECHECK_FREQ', 'discourse_comments_recheck_freq');

define('DISCOURSE_COMMENTS_VAR_CRON_LAST_RUN', 'discourse_comments_cron_last_run');


/**
 * Implements HOOK_cron().
 */
function discourse_comments_cron() {
  $last_run = variable_get(DISCOURSE_COMMENTS_VAR_CRON_LAST_RUN, 0);

  if (REQUEST_TIME - $last_run > 3600) {
    $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
    $server = variable_get(DISCOURSE_COMMENTS_VAR_SERVER, FALSE);

    if (!empty($server)) {
      try {
        $rs = db_select('discourse_queue', 'queue')
          ->fields('queue', array('entity_type', 'entity_id'))
          ->orderBy('created', 'ASC')
          ->range(0, 20)
          ->execute();

        foreach ($rs as $row) {
          $entities = entity_load($row->entity_type, array($row->entity_id));

          if (!empty($entities[$row->entity_id])) {
            $entity = $entities[$row->entity_id];

            // On new article creation, inform Discourse of the upload.
            $post = new DiscoursePost($protocol . $server['host'], $server['api_key'], $server['api_username']);
            $resp = $post->createTopic($entity, $row->entity_type);
          }

          db_delete('discourse_queue')
            ->condition('entity_type', $row->entity_type)
            ->condition('entity_id', $row->entity_id)
            ->execute();
        }
      } catch (Exception $ex) {
        watchdog_exception('discourse', $ex);
      }
    }

    variable_set(DISCOURSE_COMMENTS_VAR_CRON_LAST_RUN, REQUEST_TIME);
  }
}

/**
 * Implements HOOK_menu().
 */
function discourse_comments_menu() {
  $menu = array(
    'admin/config/content/discourse_comments' => array(
      'title' => 'Discourse Comments',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('discourse_comments_settings_form'),
      'access arguments' => array('administer site configuration'),
      'file' => 'pages/admin.inc',
      'description' => 'Configure Discourse server and comments settings.',
    ),
    'admin/config/content/discourse_comments/settings' => array(
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'title' => 'Settings',
      'weight' => 20,
    ),

    'admin/config/content/discourse_comments/entities' => array(
      'type' => MENU_LOCAL_TASK,
      'title' => 'Entity',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('discourse_comments_entities_form'),
      'access arguments' => array('administer site configuration'),
      'file' => 'pages/admin.inc',
    ),
  );

  return $menu;
}

/**
 * Implements HOOK_field_extra_fields().
 */
function discourse_comments_field_extra_fields() {
  $extra = array();
  $has_discourse = variable_get(DISCOURSE_COMMENTS_VAR_ENTITIES, array());

  foreach ($has_discourse as $type => $bundles) {
    foreach ($bundles as $bundle => $info) {
      $extras[$type][$bundle]['display'] = array(
        'discourse_comments_link' => array(
          'label' => t('Discourse comments link'),
          'weight' => 1,
          'description' => t('Link to the discourse topic.'),
        ),
        'discourse_comments' => array(
          'label' => t('Discourse discussion'),
          'weight' => 50,
          'description' => t('Comments from a discuss topic.'),
        ),
      );
    }
  }

  return $extras;
}

/**
 * Implements HOOK_entity_insert().
 */
function discourse_comments_entity_insert($entity, $type) {
  if ($entity->status != NODE_PUBLISHED) {
    return;
  }

  $entities = variable_get(DISCOURSE_COMMENTS_VAR_ENTITIES, array());
  list($id, $rev, $bundle) = entity_extract_ids($type, $entity);

  // Catch the error so it doesn't prevent the saving of the rest
  // of the entity from occurring.
  try {
    $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
    $server = variable_get(DISCOURSE_COMMENTS_VAR_SERVER, FALSE);

    if (!empty($server['host']) && !empty($entities[$type][$bundle])) {
      extract($server);

      // On new article creation, inform Discourse of the upload.
      $post = new DiscoursePost($protocol . $host, $api_key, $api_username);
      $resp = $post->createTopic($entity, $type);

      db_delete('discourse_queue')
        ->condition('entity_id', $id)
        ->condition('entity_type', $type)
        ->execute();
    }
  }
  catch (Exception $ex) {
    watchdog_exception('discourse', $ex);

    db_merge('discourse_queue')
      ->key(array('entity_id' => $id, 'entity_type' => $type))
      ->fields(array('created' => REQUEST_TIME))
      ->execute();
  }
}

/**
 * Implements HOOK_entity_update().
 */
function discourse_comments_entity_update($entity, $type) {
  if ($entity->status != NODE_PUBLISHED) {
    return;
  }

  $entities = variable_get(DISCOURSE_COMMENTS_VAR_ENTITIES, array());
  list($id, $rev, $bundle) = entity_extract_ids($type, $entity);

  if (!empty($entities[$type][$bundle])) {
    $query = db_select('discourse_comments', 'dc')
      ->condition('entity_type', $type)
      ->condition('entity_id', $id);

    $query->addExpression('COUNT(1)');

    if (!((bool)$query->execute()->fetchField())) {
      discourse_comments_entity_insert($entity, $type);
    }
  }
}

/**
 * Implements HOOK_entity_view().
 */
function discourse_comments_entity_view($entity, $type, $view_mode, $langcode) {
  if (!empty($entity->discoursePreview)) {
    return;
  }

  list($id, $rev, $bundle) = entity_extract_ids($type, $entity);
  $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
  $server = variable_get(DISCOURSE_COMMENTS_VAR_SERVER, FALSE);
  $extras = field_extra_fields_get_display($type, $bundle, $view_mode);

  // If information is available
  if (!empty($server['host']) && !empty($extras['discourse_comments']['visible']) || !empty($extras['discourse_comments_link']['visible'])) {
    try {
      $dc = db_select('discourse_comments', 'dc')
        ->fields('dc', array('topic_id', 'topic_slug'))
        ->condition('entity_type', $type)
        ->condition('entity_id', $id)
        ->execute()->fetchObject();

      if (!$dc) {
        $entities = variable_get(DISCOURSE_COMMENTS_VAR_ENTITIES, array());

        if (!variable_get(DISCOURSE_COMMENTS_VAR_POST_MISSING, FALSE) || empty($entities[$type][$bundle])) {
          return;
        }

        $post = new DiscoursePost($protocol . $server['host'], $server['api_key'], $server['api_username']);
        $dc   = $post->createTopic($entity, $type);
      }

      if ($dc) {
        $topic = (object) array('id' => $dc->topic_id, 'slug' => $dc->topic_slug);
        $topic_url = check_url("$server[host]/t/$topic->slug/$topic->id");
        $params = variable_get(DISCOURSE_COMMENTS_VAR_FETCH_PARAMS, array('best' => 5));

        // Pull comment information directly from discourse servers using AJAX
        drupal_add_js(drupal_get_path('module', 'discourse_comments') .'/js/discourse-comments.js');
        drupal_add_js(array('discourseComments' => array(
          'host' => $protocol  . $server['host'],
          'topic' => $topic,
          'params' => $params,
        )), 'setting');

        $entity->content['discourse_comments_link'] = array(
          '#prefix' => '<div class="discourse-comments-link">',
          '#suffix' => '</div>',
          '#type' => 'link',
          '#title' => '<i class="fa fa-comment"></i> <span class="comment-count">0</span> Comments',
          '#href' => $protocol . $topic_url,
          '#options' => array('html' => TRUE, 'attributes' => array('target' => '_blank')),
        );

        if (!empty($extras['discourse_comments']['visible'])) {
          $entity->content['discourse_comments'] = array(
            '#theme'      => 'discourse_comments',
            '#topic_id'   => $topic->id,
            '#topic_slug' => $topic->slug,
            '#topic_url' => $protocol . $topic_url,
          );
        }
      }
    }
    catch(Exception $e) {
      watchdog_exception('discourse_comments', $e);
    }
  }
}

/**
 * Implements HOOK_theme().
 */
function discourse_comments_theme($existing, $type, $theme, $path) {
  $base = array(
    'path' => $path .'/theme',
    'file' => 'theme.inc',
  );

  return array(
    'discourse_comment' => array(
      'variables' => array('post' => NULL, 'topic_url' => NULL),
      'template' => 'discourse-comment',
    ) + $base,
    'discourse_comments' => array(
      'render element' => 'comments',
      'template' => 'discourse-comments',
    ) + $base,
  );
}
