<?php
/**
 * @file iwsearch.module
 * Core module HOOKs and global utilities for iwentity_solr module.
 */

define('IWSEARCH_VAR_CRON_LIMIT', 'iwsearch_cron_limit');


/**
 * Implements HOOK_cron().
 */
function iwsearch_cron() {
  /**
   *  TODO: Add local index types. Currently only supporting
   *  Solr based queries.
   *  
  require_once dirname(__FILE__) .'/includes/indexing.inc';

  $query = 'SELECT name FROM {iwsearch_instances} WHERE local_index=:indexed ORDER BY last_indexed ASC';
  $names = db_query($query, array(':indexed' => 1))->fetchCol();
  $limit = variable_get(IWSEARCH_VAR_CRON_LIMIT, 50);
  
  // Iterate through the instances which have locally stored indexes.
  foreach ($names as $name) {
    $instance = iwsearch_instance_load($name);
    _iwsearch_update_local_index($instance, $limit);
    
    // Check if there are any remaining search items.
    if ($limit <= 0) {
      break;
    }
  }
  */
}

/**
 * Implements HOOK_menu().
 */
function iwsearch_menu() {
  $inst_uri = 'admin/config/search/iwsearch/%iwsearch_instance';
  
  $menu = array(
    'admin/config/search/iwsearch' => array(
      'title' => 'IW Search Instances',
      'page callback' => 'iwsearch_manage_instances_page',
      'access arguments' => array('administer search'),
       'file' => 'pages/admin.inc',
       'description' => 'Configure Image Works search instances.',
    ),
    'admin/config/search/iwsearch/_add' => array(
      'type' => MENU_LOCAL_ACTION,
      'title' => 'Add Search',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('iwsearch_instance_edit_form'),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
    ),
    $inst_uri => array(
      'title callback' => 'iwsearch_title_callback',
      'title arguments' => array(4),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('iwsearch_instance_edit_form', 4),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
    ),
    "$inst_uri/edit" => array(
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'title' => 'Edit',
      'weight' => -5,
    ),
    "$inst_uri/elements" => array(
      'type' => MENU_LOCAL_TASK,
      'title' => 'Fields',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('iwsearch_instance_fields_form', 4),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
      'weight' => 5,
    ),
    "$inst_uri/results" => array(
      'type' => MENU_LOCAL_TASK,
      'title' => 'Results',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('_iwsearch_instance_results_overview_form', 4),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
      'weight' => 10,
    ),
    "$inst_uri/results/%iwsearch_result/edit" => array(
      'type' => MENU_NORMAL_ITEM,
      'title' => 'Edit Results Page',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('iwsearch_instance_results_form', 6),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
      'weight' => 10,
    ),
    "$inst_uri/results/%iwsearch_result/delete" => array(
      'type' => MENU_NORMAL_ITEM,
      'title' => 'Confirm Results Page Delete',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('', 6),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
      'weight' => 10,
    ),
    "$inst_uri/delete" => array(
      'title' => 'Edit Search Instance',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('iwsearch_instance_delete_confirm', 4),
      'access arguments' => array('administer search'),
      'file' => 'pages/admin.inc',
    ),
  );
  
  $has_ajax["$inst_uri/elements/nojs/%/edit"] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Edit Search Element',
    'page callback' => '_iwsearch_field_element_edit_page',
    'page arguments' => array(4, 7, FALSE),
    'access arguments' => array('administer search'),
    'file' => 'pages/field_elements.inc',
  );
  $has_ajax["$inst_uri/elements/nojs/%/delete"] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Delete Search Element',
    'page callback' => '_iwsearch_field_element_delete_page',
    'page arguments' => array(4, 7, FALSE),
    'access arguments' => array('administer search'),
    'file' => 'pages/field_elements.inc',
  );
  
  // Create all the menu items for search pages.
  $rs = db_select('iwsearch_results', 'result')
    ->fields('result', array('id', 'title', 'uri', 'has_ajax'))
    ->execute();
  
  foreach ($rs as $result) {
    $menu[$result->uri] = array(
      'title' => $result->title,
      'page callback' => 'iwsearch_default_results_page',
      'page arguments' => array($result->id),
      'access arguments' => array('access content'),
      'file' => 'pages/results_page.inc',
    );
    
    if((bool)$result->has_ajax) {
      $menu[$result->uri .'/ajax-load'] = array(
        'type' => MENU_CALLBACK,
        'title' => $result->title,
        'delivery callback' => 'ajax_deliver',
        'theme callback' => 'ajax_base_page_theme',
        'page callback' => 'iwsearch_default_results_ajax',
        'page arguments' => array($result->id),
        'access arguments' => array('access content'),
        'file' => 'pages/results_page.inc',
      );
    }
  }
 
  // Add AJAX versions of menu callbacks.
  iwapi_include('menu');
  _iwapi_menu_add_ajax_items('iwsearch', $has_ajax, $menu);

  return $menu;
}

/**
 * Implements HOOK_entity_info_alter().
 */
function iwsearch_entity_info_alter(array &$entity_info) {
  // Iterate all entities and add the required search view_modes.
  foreach ($entity_info as $type => &$info) {
    if (!empty($info['searchable']) && isset($info['entity class']) && is_subclass_of($info['entity class'], 'iwEntity')) {
      $info['view modes'] += array(
        'search_index' => array(
          'label' => t('Search index'),
          'custom settings' => FALSE,
        ),
        'search_result' => array(
          'label' => t('Search result'),
          'custom settings' => FALSE,
        ),
      );
    }
  }
  
  // make sure to disconnect the info reference.
  unset($info);
}

/**
 * Implements HOOK_block_info().
 */
function iwsearch_block_info() {
  $blocks = array();
  
  if (db_table_exists('iwsearch_results') && db_field_exists('iwsearch_results', 'has_block')) {
    $query = db_select('iwsearch_results', 'result')
      ->fields('result', array('id', 'name', 'label'))
      ->condition('has_block', 1);
  
    foreach ($query->execute() as $result) {
      $blocks[$result->id] = array(
      'info' => t('iwsearch: @label (@name)', array(
          '@name' => $result->name,
          '@label' => $result->label,
        )),
        'cache' => DRUPAL_CACHE_GLOBAL,
      );
    }
  }
  
  return $blocks;
}

/**
 * Implements HOOK_block_view().
 */
function iwsearch_block_view($delta) {
  if ($handler = iwsearch_result_load($delta)) {
    require_once __DIR__ .'/pages/results_page.inc';
    
    return array(
      'subject' => check_plain($handler->title),
      'content' => array(
        'form' => drupal_get_form('iwsearch_search_form', $handler),
      ),
    );
  }
}

/**
 * Implements HOOK_field_storage_pre_update().
 */
function iwsearch_field_storage_pre_update($entity_type, $entity, &$skip_fields) {
  list($id, $rev, $bundle) = entity_extract_ids($entity_type, $entity);

  $instances = field_info_instances($entity_type, $bundle);
  foreach ($instances as $fieldname => $inst) {
    $field = field_info_field_by_id($inst['field_id']);

    if ($field['type'] == 'entityreference') {
      cache_clear_all('iwsearch:field_allowed:'. $fieldname, 'cache', TRUE);
    }
  }
}

/**
 * Implements HOOK_field_create_field().
 */
function iwsearch_field_create_field($field) {
  cache_clear_all('iwsearch:singular_field_mapping', 'cache');
}

/**
 * Implements HOOK_field_update_field().
 */
function iwsearch_field_update_field($field, $old_field, $has_data) {
  if (($field['cardinality'] == 1) != ($old_field['cardinality'] == 1)) {
    cache_clear_all('iwsearch:singular_field_mapping', 'cache');
  }
}

/**
 * Implements HOOK_theme().
 */
function iwsearch_theme($existing, $type, $theme, $path) {
  $base = array(
    'path' => $path .'/theme',
    'file' => 'theme.inc',
  );
  
  return array(
    'iwsearch_results' => array(
      'render element' => 'element',
      'pattern' => 'iwsearch_results__',
      'template' => 'iwsearch-results',
    ) + $base,
  );
}


// =============================
// Menu callbacks and loading
// =============================

/**
 * The menu title callback to return the name of
 * a search page.
 * 
 * @param iwSearchProvider $provider
 *  The search provider being used.
 * @return string
 *  The label set for the search provider.
 */
function iwsearch_title_callback(iwSearchProvider $provider) {
  return $provider->label;
}

/**
 * Menu load callback to return an iwsearch instance objects.
 * 
 * @param string $name
 *  Name of the search instance to load. 
 * @return iwSearchProvider | FALSE
 *  Instance matching the name
 * 
 * @see _iwsearch_instance_load_unchanged().
 */
function iwsearch_instance_load($name) {
  $instances = &drupal_static(__FUNCTION__);
  
  $name = strtr($name, '-', '_'); 
  if (!isset($instances[$name])) {
    $instances[$name] = _iwsearch_instance_load_unchanged($name);
  }
  
  return $instances[$name];
}

/**
 * Load a search instance from the database data
 * only. This will always load and build a new
 * copy from the database. To reference the cached
 * or active version use iwsearch_instance_load()
 * instead of this directly.
 * 
 * @param string $name
 *  Name of the search instance to load.
 * @return iwSearchProvider | FALSE
 *  Instance matching the name
 */
function _iwsearch_instance_load_unchanged($name) {
  $row = db_select('iwsearch_instances', 'inst')
    ->fields('inst')
    ->condition('name', $name)
    ->execute()->fetchAssoc();
  
  return $row ? iwSearchProvider::BuildProvider($row) : FALSE;
}

/**
 * Load callback to load a search results handler
 * which can be used to render page results.
 * 
 * @param string $id
 *  The id of the results handler. 
 */
function iwsearch_result_load($id) {
  $results = &drupal_static(__FUNCTION__);
  
  if (!isset($results) || !key_exists($id, $results)) {
    $row = db_select('iwsearch_results', 'result')
      ->fields('result')
      ->condition('id', $id)
      ->execute()->fetchAssoc();
    
    if ($row) {
      $provider = iwsearch_instance_load($row['name']);
      $className = $row['handler'];
      
      $results[$id] = new $className($provider, $row + unserialize($row['data']));
    }
    else {
      $results[$id] = FALSE;
    }
  }

  return $results[$id];
}


// ====================================
// Apache Solr HOOKs & callbacks
// ====================================

/**
 * Implements HOOK_apachesolr_field_mappings_alter();
 * 
 * Make changes to how Solr recognizes these fields. With
 * everything marked as multiple even if field cardinality
 * is 1, prevents them from being properly searchable.
 */
function iwsearch_apachesolr_field_mappings_alter(&$mappings, $entity_type) {
  $cid = 'iwsearch:singular_field_mapping';
  
  if ($cache = cache_get($cid)) {
    $singles = $cache->data;
  }
  else {
    $query = db_select('field_config', 'config')
      ->fields('config', array('type', 'cardinality'))
      ->condition('type', array_keys($mappings))
      ->condition('active', 1)
      ->groupby('type') 
      ->groupby('cardinality');

    $singles   = array();
    $multiples = array();
    foreach ($query->execute() as $values) {
      if ($values->cardinality == 1) {
        $singles[$values->type] = TRUE;
      }
      else {
        $multiples[$values->type] = TRUE;
      }
    }

    $per_field = array();
    foreach (array_intersect_key($singles, $multiples) as $type => $value) {
      unset($singles[$type]);

      $per_field += db_select('field_config', 'config')
        ->fields('config', array('field_name', 'type'))
        ->condition('type', $type)
        ->condition('cardinality', 1)
        ->execute()->fetchAllKeyed();
    }

    $singles['per-field'] = $per_field;
    cache_set($cid, $singles);
  }
  
  $per_field = $singles['per-field'];
  unset($singles['per-field']);
  
  // Apply all fields that only contain single values.
  foreach ($singles as $type => $values) {
    $mappings[$type]['multiple'] = FALSE;
  }
  
  // Take care of per-field items.
  foreach ($per_field as $field => $key) {
    if (!isset($mappings['per-field'][$field])) {
      $mappings['per-field'][$field] = array('multiple' => FALSE) + $mappings[$key];
    }
  } 
}

/**
 * Implements HOOK_apachesolr_entity_info_alter().
 */
function iwsearch_apachesolr_entity_info_alter(&$entity_info) {
  _iwsearch_reset_search_entities();
  
  // Iterate through supported entities and report them to Solr.
  foreach (_iwsearch_get_search_entities() as $type => $info) {
    $entity_info[$type] = $info + array(
      'indexable'         => TRUE,
      'status callback'   => array('_iwsearch_solr_entity_status'),
      'document callback' => array('_iwsearch_solr_entity_document'),
      'reindex callback'  => '_iwsearch_solr_entity_reindex',
    );
  }
}

/**
 * Default entity status callback for Solr. 
 * 
 * @param $entity_id
 *  The ID of the entity which we are trying to load.
 * @param $entity_type
 *  The type of the entity which is being loaded.
 * @return boolean
 *  Whether or not this entity can be considered active.
 */
function _iwsearch_solr_entity_status($entity_id, $entity_type) {
  $entities = entity_load($entity_type, array($entity_id));

  if ($entity = reset($entities)) {
    // iwEntity::getStatus() will return IWAPI_INACTIVE on errors,
    // so it is safe to compare to IWAPI_INACTIVE for the status.
    return $entity->getStatus() != IWAPI_INACTIVE;
  }
  return FALSE;
}

/**
 * Default entity document callback for Solr.
 * 
 * @param ApacheSolrDocument $doc
 *  The currently created document which Solr will index.
 * @param iwEntity $entity
 *  The entity to get indexed by Solr
 * @param string $entity_type
 *  The machine name of the entity type being represented.
 * @param string $env_id
 *  Name of the Solr instance environment ID.
 * @return array
 *  Returns and array with all the Solr Documents, ready to send
 *  to the Solr server instance. Currently returned only one document
 *  but the apachesolr module is preparing to allow multiples.
 */
function _iwsearch_solr_entity_document(ApacheSolrDocument $doc, iwEntity $entity, $entity_type, $env_id) {
  // Start populating a Solr document.
  $doc->label     = apachesolr_clean_text($entity->getLabel());
  $doc->bs_status = $entity->getStatus();
  
  // Get additional entity properties and add searchable items.
  $properties = iwapi_get_entity_properties($entity_type);
    
  foreach ($properties as $name => $property) {
    $search_info = $property->getSearchInfo();
 
    if (!empty($search_info)) {
      // Special treatment for author properties.
      if ($property instanceof iwAuthorProperty) {
        $search_info['index_type'] = 'text-omitNorms';
        
        // Add the {users}.uid to the search index.
        $uidKey = apachesolr_index_key(array(
          'name' => $property->authorKey,
          'index_type' => 'integer',
          'multiple' => $property->multi,
        ));
        $doc->{$uidKey} = $entity->{$property->authorKey};
      }
      
      $index_key = apachesolr_index_key($search_info);
      $doc->{$index_key} = _iwsearch_format_solr_values(
        $property->getValue($entity),
        $search_info['index_type'],
        $search_info['multiple']
      );
    }
  }

  // Not all entities have this but those that don't will
  // automatically be reverted to the default view.
  $build = $entity->view('search_index');
  unset($build['#theme']);  // essentially just build the field values
  
  // Apache filters / cleans text before storage
  $content = drupal_render($build);
  $doc->content = apachesolr_clean_text($content);
  $doc->teaser  = truncate_utf8($doc->content, 300, TRUE);
  
  // Add path aliases to the index, if there is one
  if (function_exists('drupal_get_path_alias')) {
    $uri = $entity->getUri();
    $output = drupal_get_path_alias($uri['path']);
    if ($output && $output != $uri['path']) {
      $doc->path_alias = $output;
    }
  }  
  
  // Allow custom entity types to include have additional handling.
  drupal_alter('iwsearch_solr_index', $doc, $entity, $entity_type);
  return array($doc);
}

/**
 * Default Solr entity indexing function, to build a
 * list of all entities that need to be re-indexed.
 * 
 * @param string $env_id
 *  Name of the Solr Environment that the search
 *  is being built for.
 * @param string $bundle
 *  Name of the bundle to build the search id for.
 */
function _iwsearch_solr_entity_reindex($env_id, $bundle = NULL) {
  if (isset($bundle)) {
    drupal_set_message(t('Unable to index by bundle: %bundle', array('%bundle' => $bundle)));
    watchdog('iwentity_solr', '', array('%bundle' => $bundle));
    return;
  }
  
  // Iterate through allowed search entities and include items.
  foreach (_iwsearch_get_search_entities() as $type => $info) {
    $index_table = apachesolr_get_indexer_table($type);
    $bundles     = apachesolr_get_index_bundles($env_id, $type);
    $ent_info    = entity_get_info($type);
    
    if (empty($bundles)) {
      continue;
    }
    
    $transaction = db_transaction('iwSearchInstance');
    try {
      db_delete($index_table)
        ->condition('status', 1)
        ->condition('entity_type', $type)
        ->execute();
      
      // Build query to find all usable entities to add to the indexer.
      $keys = $ent_info['entity keys'] + array('status' => 'status');
      $select = db_select($ent_info['base table'], 'ent')
        ->condition($keys['status'], IWAPI_INACTIVE, '<>')
        ->condition($keys['bundle'], $bundles, 'IN');
      
      $select->addExpression("'{$type}'", 'entity_type');
      $select->addField('ent', $keys['id'], 'entity_id');
      $select->addField('ent', $keys['bundle'], 'bundle');
      $select->addField('ent', $keys['status'], 'status');
      $select->addExpression(REQUEST_TIME, 'changed');

      db_insert($index_table)
        ->fields(array('entity_id', 'bundle', 'status', 'entity_type', 'changed'))
        ->from($select)
        ->execute();
    }
    catch (Exception $e) {
      $transaction->rollback();
      throw $e;  // Rethrow so that callers can know of the failure.
    }
  }
}

/**
 * Callback function to format a property values
 * based on type for Apache Solr to evaluate.
 * 
 * Unlike _iwsearch_format_solr_value() this version
 * will handle multiple values.
 * 
 * @param type $values
 *  Value to format, should be of hte appropriate type.
 * @param string $type
 *  Data type of value (string, date, boolean, etc...)
 * @return string | array
 *  Cleaned and formatted values or value using _iwsearch_format_solr_values.
 */
function _iwsearch_format_solr_values($values, $type, $multi = FALSE) {
  if ($multi && is_array($values)) {
    array_walk($values, '_iwsearch_format_solr_value', $type);
    return $values;
  }
  else {
    return _iwsearch_format_solr_value($values, $type);
  }
}

/**
 * Callback function to format a property value
 * based on type for Apache Solr to evaluate.
 * 
 * @param type $value
 *  Value to format, should be of hte appropriate type.
 * @param string $type
 *  Data type of value (string, date, boolean, etc...)
 * @return string
 *  Cleaned and formatted value appropriate for
 *  use with Solr.
 */
function _iwsearch_format_solr_value(&$value, $type) {
  switch ($type) {
    case 'date':
      return apachesolr_date_iso($value);

    case 'boolean':
      return !empty($value);

    case 'point':
    case 'location':
      return number_format($value['lat'], 10) .','. number_format($value['lng'], 10);

    case 'text-omitNorms':
      return $value;

    case 'string':
    default:
      return apachesolr_clean_text($value);
  }
}


// ====================================
// Global utilities.
// ====================================

/**
 * Report all supported and known search providers
 * for use with the Image Works Search module.
 */
function _iwsearch_get_search_providers($reset = FALSE) {
  $providers = &drupal_static(__FUNCTION__, NULL);
  $cid = 'iwsearch:search_providers';

  if ($reset || !isset($providers)) {
    if (!$reset && ($cache = cache_get($cid))) {
      $providers = $cache->data;
    }
    else {
      $providers = array();

      // TODO: Concentrating on the Apache Solr implementation
      // for the time being, but this needs to be properly built.
      // --------------------------------------------------------
      // $providers['iwDbSearchProvider'] = t('Drupal Search');
      if (module_exists('apachesolr')) {
        $providers['iwSolrSearchProvider'] = t('Apache Solr');
      }
  
      $providers += module_invoke_all('iwsearch_providers');
      cache_set($cid, $providers);
    }
  }
  return $providers;
}

/**
 * Get information about search entities provided
 * that can be provided to the Solr search service.
 */
function _iwsearch_get_search_entities() {
  $search_entities = &drupal_static(__FUNCTION__);
  
  // Build a list of entities Solr should be aware of.
  if (!isset($search_entities)) {
    $search_entities = array();
    
    // Find entities marked as searchable and a subclass of iwEntity.
    foreach (entity_get_info() as $entity_type => $info) {
      if (!empty($info['searchable']) && isset($info['entity class']) && is_subclass_of($info['entity class'], 'iwEntity')) {
        $data = array('label' => $info['label']);
        
        // If a table following this naming convention is available, use it for
        // the apache index table. Otherwise we'll use {apachesolr_index_entities}.
        if (db_table_exists('apachesolr_index_entities_'. $entity_type)) {
          $data['index_table'] = 'apachesolr_index_entities_'. $entity_type;
        }
        $search_entities[$entity_type] = $data;
      }
    }

    // Resolve information about what entities are available for searching.
    drupal_alter('iwsearch_apachesolr_info', $search_entities);
  }
  return $search_entities;
}

/**
 * Reset the status of the search entities. Usually called, if
 * there maybe changes in modules or entity info.
 */
function _iwsearch_reset_search_entities() {
  drupal_static_reset('_iwsearch_get_search_entities');
}

/**
 * Element validate callback for form processing, to validate that
 * the path requested for a result path a useable path and that
 * it is not already being used else where.
 */
function iwsearch_element_validate_result_path($element, &$form_state, $form) {  
  $uri = trim($element['#value'], " \t\r\n/");

  if (!empty($uri)) {
    if (preg_match_all('#[^\w\-_/]#', $uri, $matches)) {
      $chars = implode(', ', array_unique($matches[0]));
      form_error($element, t('Invalid character(s): %chars', array('%chars' => $chars)));
    }
    elseif ($item = menu_get_item($uri)) {
      $results_id = reset($item['page_arguments']);

      if ($item['path'] !== $uri || ($item['page_callback'] == 'iwsearch_default_results_page' && $results_id === $form_state['search_results']->id)) {
        return; // Verified that existing path is being used by same instance.
      }
      
      // Report that path is already in use.
      form_error($element, t(
        'This menu path is already in use, please select a different '.
        'path in order to avoid conflicts with routing requests.'
      ));
    }                            
  }
}
